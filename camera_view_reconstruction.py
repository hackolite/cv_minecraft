#!/usr/bin/env python3
"""
Camera View Reconstruction Script
==================================

Reconstruct a camera view from JSON data and generate a screenshot.png

This script:
1. Loads camera view data from a JSON file (generated by camera_view_query.py)
2. Renders the blocks from the camera's perspective
3. Generates a screenshot.png file

The reconstruction is done client-side using simple 2D projection.

Usage:
    python3 camera_view_reconstruction.py [--input INPUT_FILE] [--output OUTPUT_IMAGE]
"""

import json
import math
import argparse
from typing import Dict, Any, List, Tuple
from PIL import Image, ImageDraw, ImageFont


# Block type colors (RGB)
BLOCK_COLORS = {
    "grass": (34, 139, 34),      # Forest green
    "sand": (238, 214, 175),     # Wheat
    "brick": (178, 34, 34),      # Firebrick
    "stone": (128, 128, 128),    # Gray
    "wood": (139, 69, 19),       # Saddle brown
    "leaf": (0, 128, 0),         # Green
    "water": (64, 164, 223),     # Dodger blue with transparency
    "camera": (0, 0, 255),       # Blue
    "user": (255, 255, 0),       # Yellow
    "air": (0, 0, 0, 0),         # Transparent
    "cat": (255, 165, 0),        # Orange
}


def project_3d_to_2d(
    point: Tuple[float, float, float],
    camera_pos: Tuple[float, float, float],
    rotation: Tuple[float, float],
    fov: float = 70.0,
    width: int = 800,
    height: int = 600
) -> Tuple[int, int, float]:
    """Project a 3D point to 2D screen coordinates.
    
    Args:
        point: 3D point position (x, y, z)
        camera_pos: Camera position (x, y, z)
        rotation: Camera rotation (horizontal, vertical) in degrees
        fov: Field of view in degrees
        width: Screen width in pixels
        height: Screen height in pixels
        
    Returns:
        Tuple of (screen_x, screen_y, depth)
    """
    px, py, pz = point
    cx, cy, cz = camera_pos
    h_rot, v_rot = rotation
    
    # Translate point to camera space
    dx = px - cx
    dy = py - cy
    dz = pz - cz
    
    # Rotate around Y axis (horizontal rotation)
    h_rad = math.radians(h_rot)
    rotated_x = dx * math.cos(h_rad) + dz * math.sin(h_rad)
    rotated_z = -dx * math.sin(h_rad) + dz * math.cos(h_rad)
    rotated_y = dy
    
    # Rotate around X axis (vertical rotation)
    v_rad = math.radians(v_rot)
    final_y = rotated_y * math.cos(v_rad) - rotated_z * math.sin(v_rad)
    final_z = rotated_y * math.sin(v_rad) + rotated_z * math.cos(v_rad)
    final_x = rotated_x
    
    # Avoid division by zero
    if final_z <= 0.1:
        return (width // 2, height // 2, 0)
    
    # Perspective projection
    fov_rad = math.radians(fov)
    scale = (width / 2) / math.tan(fov_rad / 2)
    
    screen_x = int(width / 2 + (final_x / final_z) * scale)
    screen_y = int(height / 2 + (final_y / final_z) * scale)
    
    return (screen_x, screen_y, final_z)


def get_block_brightness(position: Tuple[int, int, int], camera_pos: Tuple[float, float, float]) -> float:
    """Calculate brightness based on distance from camera.
    
    Args:
        position: Block position
        camera_pos: Camera position
        
    Returns:
        Brightness factor (0.0 to 1.0)
    """
    dx = position[0] - camera_pos[0]
    dy = position[1] - camera_pos[1]
    dz = position[2] - camera_pos[2]
    distance = math.sqrt(dx*dx + dy*dy + dz*dz)
    
    # Fade with distance
    max_distance = 50.0
    brightness = max(0.3, 1.0 - (distance / max_distance))
    return brightness


def apply_brightness(color: Tuple[int, int, int], brightness: float) -> Tuple[int, int, int]:
    """Apply brightness to a color.
    
    Args:
        color: RGB color tuple
        brightness: Brightness factor (0.0 to 1.0)
        
    Returns:
        Adjusted RGB color tuple
    """
    r, g, b = color
    return (
        int(r * brightness),
        int(g * brightness),
        int(b * brightness)
    )


def render_camera_view(
    view_data: Dict[str, Any],
    width: int = 800,
    height: int = 600,
    fov: float = 70.0
) -> Image.Image:
    """Render camera view from data.
    
    Args:
        view_data: Camera view data dictionary
        width: Image width in pixels
        height: Image height in pixels
        fov: Field of view in degrees
        
    Returns:
        PIL Image object
    """
    # Create image with sky background
    img = Image.new('RGB', (width, height), color=(135, 206, 235))  # Sky blue
    draw = ImageDraw.Draw(img)
    
    # Extract camera info
    camera_info = view_data["camera"]
    camera_pos = tuple(camera_info["position"])
    rotation = tuple(camera_info["rotation"])
    
    # Extract blocks
    blocks = view_data["blocks"]
    
    print(f"üé® Rendering {len(blocks)} blocks from camera perspective...")
    print(f"   Camera position: {camera_pos}")
    print(f"   Camera rotation: {rotation}")
    
    # Sort blocks by distance (far to near for proper occlusion)
    blocks_with_depth = []
    for block in blocks:
        pos = tuple(block["position"])
        block_type = block["block_type"]
        
        # Skip air blocks
        if block_type == "air":
            continue
        
        # Project block center to screen
        screen_x, screen_y, depth = project_3d_to_2d(
            pos, camera_pos, rotation, fov, width, height
        )
        
        # Skip blocks behind camera or off screen
        if depth <= 0.1:
            continue
        if screen_x < -100 or screen_x > width + 100:
            continue
        if screen_y < -100 or screen_y > height + 100:
            continue
        
        blocks_with_depth.append((depth, block, screen_x, screen_y))
    
    # Sort by depth (furthest first)
    blocks_with_depth.sort(key=lambda x: x[0], reverse=True)
    
    print(f"   Rendering {len(blocks_with_depth)} visible blocks...")
    
    # Draw blocks
    for depth, block, screen_x, screen_y in blocks_with_depth:
        block_type = block["block_type"]
        pos = tuple(block["position"])
        
        # Get color
        color = BLOCK_COLORS.get(block_type, (128, 128, 128))
        
        # Apply distance-based brightness
        brightness = get_block_brightness(pos, camera_pos)
        color = apply_brightness(color, brightness)
        
        # Calculate size based on depth (perspective)
        base_size = 20
        size = max(2, int(base_size / max(depth, 0.5)))
        
        # Draw block as rectangle
        x1 = screen_x - size // 2
        y1 = screen_y - size // 2
        x2 = screen_x + size // 2
        y2 = screen_y + size // 2
        
        draw.rectangle([x1, y1, x2, y2], fill=color, outline=(0, 0, 0))
    
    # Draw info overlay
    try:
        # Try to use a font, fall back to default if not available
        font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 12)
    except:
        font = ImageFont.load_default()
    
    info_text = f"Camera: {camera_info['block_id']} | Pos: {camera_pos} | Rot: {rotation} | Blocks: {len(blocks_with_depth)}"
    draw.text((10, 10), info_text, fill=(255, 255, 255), font=font)
    
    print(f"‚úÖ Rendering complete!")
    
    return img


def load_view_data(input_file: str) -> Dict[str, Any]:
    """Load view data from JSON file.
    
    Args:
        input_file: Path to input JSON file
        
    Returns:
        View data dictionary
    """
    print(f"üìÇ Loading view data from: {input_file}")
    with open(input_file, 'r') as f:
        data = json.load(f)
    
    # Validate structure
    if "camera" not in data or "blocks" not in data:
        raise ValueError("Invalid view data format")
    
    print(f"‚úÖ Loaded view data with {len(data['blocks'])} blocks")
    return data


def save_screenshot(img: Image.Image, output_file: str):
    """Save image to file.
    
    Args:
        img: PIL Image object
        output_file: Path to output image file
    """
    img.save(output_file)
    print(f"üíæ Screenshot saved to: {output_file}")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Reconstruct camera view and generate screenshot"
    )
    parser.add_argument(
        "--input",
        default="camera_view_data.json",
        help="Input JSON file with view data (default: camera_view_data.json)"
    )
    parser.add_argument(
        "--output",
        default="screenshot.png",
        help="Output screenshot file (default: screenshot.png)"
    )
    parser.add_argument(
        "--width",
        type=int,
        default=800,
        help="Image width in pixels (default: 800)"
    )
    parser.add_argument(
        "--height",
        type=int,
        default=600,
        help="Image height in pixels (default: 600)"
    )
    parser.add_argument(
        "--fov",
        type=float,
        default=70.0,
        help="Field of view in degrees (default: 70.0)"
    )
    
    args = parser.parse_args()
    
    print("=" * 70)
    print("Camera View Reconstruction Script")
    print("=" * 70)
    
    try:
        # Load view data
        view_data = load_view_data(args.input)
        
        # Render image
        img = render_camera_view(
            view_data,
            width=args.width,
            height=args.height,
            fov=args.fov
        )
        
        # Save screenshot
        save_screenshot(img, args.output)
        
        print("\n" + "=" * 70)
        print("‚úÖ Screenshot reconstruction completed successfully!")
        print("=" * 70)
        
        return 0
        
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    import sys
    sys.exit(main())
